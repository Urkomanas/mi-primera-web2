<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Outer Wilds Interactivo Mejorado</title>
<style>
:root{
  --bg:#03040a; --card:#071028; --accent:#ffd27f; --muted:#9fb4d6;
}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#dbefff;background:
  radial-gradient(ellipse at bottom,#001022 0%,var(--bg) 50%), linear-gradient(180deg,#021 0%,#000 100%);}
.container{display:flex;gap:16px;padding:18px;box-sizing:border-box;}
.left{flex:1;min-width:360px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);
  border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03)}
.header{display:flex;align-items:center;gap:12px}
.logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,#ffb86b,#ff8a8a);
  display:flex;align-items:center;justify-content:center;color:#092;font-weight:700}
.sim{background:#000;border-radius:8px;padding:8px;margin-top:12px;position:relative;overflow:hidden;height:560px}
canvas{display:block;width:100%;height:100%;background:transparent}
.controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
button{background:linear-gradient(180deg,#0b2a44,#063050);color:#dff4ff;border:1px solid rgba(255,255,255,0.04);
  padding:8px 12px;border-radius:8px;cursor:pointer}
.muted{background:transparent;border:1px dashed rgba(255,255,255,0.03);color:var(--muted)}
.panel{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px;border-radius:8px}
.log{height:220px;overflow:auto;background:rgba(255,255,255,0.01);padding:8px;border-radius:6px;font-size:13px}
.entry{padding:8px;border-radius:6px;margin-bottom:8px;background:rgba(255,255,255,0.01);display:flex;justify-content:space-between}
.right{width:380px;display:flex;flex-direction:column;gap:12px}
.panel-tall{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.015),transparent);border-radius:12px;padding:12px}
.input-file{display:flex;gap:8px;align-items:center;margin-top:8px}
.small{font-size:13px;color:var(--muted)}
.badge{display:inline-block;padding:6px;border-radius:6px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:12px}
.controls-right{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.overlay-ui{position:absolute;left:12px;top:12px;color:var(--muted);font-size:13px;z-index:3}
.zoomControls{position:absolute;right:12px;top:12px;z-index:3;display:flex;flex-direction:column;gap:6px}
footer{margin-top:12px;display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--muted)}
@media (max-width:1000px){.container{flex-direction:column}.right{width:100%}}
</style>
</head>
<body>
<div class="container">
  <div class="left">
    <div class="header">
      <div class="logo">OW</div>
      <div>
        <h1 style="margin:0">Outer Wilds Interactivo Mejorado</h1>
        <div class="small">Imágenes originales opcionales, cometa, zoom deshacer/rehacer y mini nave</div>
      </div>
    </div>

    <div class="sim" id="sim">
      <canvas id="space"></canvas>
      <div class="overlay-ui">
        <div><span class="badge" id="timeLabel">Tiempo 0</span></div>
        <div class="small">Click para centrar en planeta. WASD para pilotar la nave. Espacio para boost.</div>
      </div>
      <div class="zoomControls">
        <button id="zoomIn">+</button>
        <button id="zoomOut">−</button>
        <button id="undoZoom" class="muted">Deshacer</button>
        <button id="redoZoom" class="muted">Rehacer</button>
      </div>
    </div>

    <div class="controls">
      <button id="pauseBtn" class="muted">Pausar</button>
      <button id="fasterBtn">Acelerar ×2</button>
      <button id="eventBtn">Forzar evento</button>
      <button id="toggleTrails" class="muted">Trails</button>
      <div style="margin-left:auto" class="input-file">
        <label class="small">Cargar assets</label>
        <input id="fileInput" type="file" accept="image/*" multiple />
      </div>
    </div>

    <div class="panel">
      <div class="card">
        <strong>Sistema</strong>
        <div id="status" style="margin-top:8px">Cargando...</div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="toggleOrbits" class="muted">Mostrar órbitas</button>
          <button id="resetBtn" class="muted">Reiniciar</button>
        </div>
      </div>

      <div class="card">
        <strong>Audio</strong>
        <div style="margin-top:8px">
          <label class="small">Ambiente <span id="ambLevel">0.6</span></label>
          <input id="ambRange" type="range" min="0" max="1" step="0.01" value="0.6" />
        </div>
      </div>
    </div>

    <footer>
      <div class="small">Hecho con JS — inspiraión Outer Wilds</div>
      <div class="small">Controles: Click planetas, WASD nave, Espacio boost</div>
    </footer>
  </div>

  <div class="right">
    <div class="panel-tall">
      <strong>Ship Log</strong>
      <div class="log" id="log">
        <div class="entry unread"><div><strong>Bienvenido</strong><div class="small">Explora y registra descubrimientos.</div></div><div><button data-action="mark">Leer</button></div></div>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="noteInput" placeholder="Añade nota..." style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" />
        <button id="addNote">Añadir</button>
      </div>
      <div style="margin-top:10px" class="small">
        Arrastra imágenes aquí o usa el control Cargar assets. Nombres sugeridos para reemplazar sprites: sun.png ashtwin.png embertwin.png brittlehollow.png giantsdeep.png hourglasstwins.png comet.png ship.png
      </div>
    </div>

    <div class="card">
      <strong>Eventos recientes</strong>
      <div class="log" id="events" style="height:140px;overflow:auto">Sistema inicializado.</div>
      <div style="margin-top:8px" class="controls-right">
        <label class="small">Velocidad:</label>
        <input id="speed" type="range" min="0.25" max="4" step="0.25" value="1" />
        <div class="small">x <span id="speedVal">1</span></div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   Assets y configuración
   ========================= */
const canvas = document.getElementById('space');
const ctx = canvas.getContext('2d');
let W=canvas.width=900, H=canvas.height=560;
const simEl = document.getElementById('sim');
const timeLabel = document.getElementById('timeLabel');
const eventsEl = document.getElementById('events');
const logEl = document.getElementById('log');

let time = 0, running = true, simSpeed = 1, showOrbits=true, showTrails=false;
let zoom = 1, viewOffset = {x:0,y:0};
let zoomHistory = [], redoHistory = [];

const defaultSprites = {}; // fallback generated shapes
const assets = {}; // user images map by name

const suggestedNames = ['sun','ashtwin','embertwin','brittlehollow','giantsdeep','hourglasstwins','comet','ship'];

/* cuerpos incluyendo cometa */
const bodies = [
  {key:'ashtwin', name:'Ash Twin', d:80, r:12, color:'#c95c3b', period:18, angle:0, trail:[]},
  {key:'embertwin', name:'Ember Twin', d:140, r:16, color:'#ff9c6b', period:30, angle:2, trail:[]},
  {key:'brittlehollow', name:'Brittle Hollow', d:220, r:22, color:'#7b9ab3', period:48, angle:4, trail:[]},
  {key:'giantsdeep', name:"Giant's Deep", d:320, r:30, color:'#2b6b9b', period:80, angle:1, trail:[]},
  {key:'hourglasstwins', name:'The Hourglass Twins', d:420, r:24, color:'#d6b27a', period:140, angle:6, trail:[]},
];
const comet = {key:'comet', name:'Comet', d:500, r:8, color:'#fff', period:60, angle:3.5, trail:[], eccentric:true};

/* nave controlable */
const ship = {x:0,y:0,vx:0,vy:0,angle:0,speed:0,boost:false,imageKey:'ship'};

/* carga de imágenes si existen en /assets o por carga de usuario */
function loadImagePath(name, path){
  return new Promise((res)=>{
    const img = new Image();
    img.onload = ()=>{ assets[name]=img; res(true); };
    img.onerror = ()=>{ res(false); };
    img.src = path;
  });
}

/* intenta cargar assets locales en carpeta assets con nombres sugeridos */
(async function tryLoadAssets(){
  for(const n of suggestedNames){
    await loadImagePath(n, `assets/${n}.png`);
  }
})();

/* fallback simple para cuerpos cuando no hay imagen */
function drawBodyShape(x,y,b){
  ctx.beginPath();
  ctx.fillStyle = b.color || '#888';
  ctx.arc(x,y,b.r,0,Math.PI*2);
  ctx.fill();
}

/* Resize canvas a contenedor */
function resize(){
  W = canvas.width = canvas.clientWidth || 900;
  H = canvas.height = canvas.clientHeight || 560;
}
window.addEventListener('resize', resize);
resize();

/* utilidades */
function randChoice(a){return a[Math.floor(Math.random()*a.length)];}
function logEvent(txt){ const p=document.createElement('div'); p.textContent=`[t=${Math.floor(time)}] ${txt}`; eventsEl.prepend(p); }

/* Audio básico */
let audioCtx=null, osc=null, gain=null;
function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  osc = audioCtx.createOscillator(); gain = audioCtx.createGain();
  osc.type='sine'; osc.frequency.value=140; gain.gain.value=0.01;
  osc.connect(gain); gain.connect(audioCtx.destination); osc.start();
}
document.body.addEventListener('click', ()=>{ if(!audioCtx) ensureAudio(); }, {once:true});

/* =========================
   Dibujo y simulación
   ========================= */
let last = performance.now();
function step(now){
  const dt = Math.min(40, now - last);
  last = now;
  if(running) time += dt/1000 * simSpeed;
  updatePhysics(dt/1000);
  render();
  requestAnimationFrame(step);
}
requestAnimationFrame(step);

function worldToScreen(wx, wy){
  const cx = W/2 + (wx + viewOffset.x)*zoom;
  const cy = H/2 + (wy + viewOffset.y)*zoom;
  return {x:cx,y:cy};
}
function screenToWorld(sx, sy){
  return {x: (sx - W/2)/zoom - viewOffset.x, y: (sy - H/2)/zoom - viewOffset.y};
}

function updatePhysics(dt){
  // planet angles
  bodies.forEach(b=> b._ang = (time / b.period) * Math.PI*2 + b.angle);
  comet._ang = (time / comet.period) * Math.PI*2 + comet.angle;
  // comet eccentric movement (sweep)
  const ctheta = comet._ang;
  const ecc = 0.65;
  const cd = comet.d * (1 + ecc * Math.sin(time*0.8));
  comet._pos = {x: Math.cos(ctheta)*cd, y: Math.sin(ctheta)*cd};
  // ship physics simple: WASD direct thrust in local axes
  if(ship.thrust){
    const acc = ship.boost ? 1200 : 400;
    ship.vx += Math.cos(ship.angle) * acc * dt;
    ship.vy += Math.sin(ship.angle) * acc * dt;
  }
  // damping and integrate
  ship.vx *= 0.995; ship.vy *= 0.995;
  ship.x += ship.vx * dt; ship.y += ship.vy * dt;
  // keep ship near center if drifts too far
  if(Math.hypot(ship.x, ship.y) > 2000){ ship.x = 0; ship.y = 0; ship.vx=ship.vy=0; addLog('Ship recovered near launch'); }
}

function render(){
  ctx.clearRect(0,0,W,H);
  // starfield
  for(let i=0;i<120;i++){
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect((i*37)%W, ((i*97)%H), 1, 1);
  }
  // sun position at world (0,0)
  const sunPos = worldToScreen(0,0);
  if(assets['sun']) {
    const s = 80 * zoom;
    ctx.drawImage(assets['sun'], sunPos.x - s/2, sunPos.y - s/2, s, s);
  } else {
    ctx.beginPath(); ctx.fillStyle='#ffd27f'; ctx.shadowBlur=20; ctx.shadowColor='#ffd27f';
    ctx.arc(sunPos.x, sunPos.y, 28*zoom, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
  }

  // orbits and planets
  bodies.forEach(b=>{
    // orbit
    const r = b.d;
    if(showOrbits){
      ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1;
      const steps = 120; ctx.save(); ctx.translate(W/2 + viewOffset.x*zoom, H/2 + viewOffset.y*zoom);
      ctx.scale(zoom,zoom); ctx.beginPath(); ctx.ellipse(0,0, r, r, 0,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
    // planet pos
    const ang = b._ang || ((time / b.period) * Math.PI*2 + b.angle);
    const wx = Math.cos(ang) * b.d;
    const wy = Math.sin(ang) * b.d;
    const screen = worldToScreen(wx, wy);
    // trail
    if(showTrails){
      b.trail.push({x:screen.x,y:screen.y});
      if(b.trail.length>60) b.trail.shift();
      ctx.beginPath(); ctx.strokeStyle = b.color; ctx.globalAlpha = 0.2;
      b.trail.forEach((p,i)=> i? ctx.lineTo(p.x,p.y): ctx.moveTo(p.x,p.y));
      ctx.stroke(); ctx.globalAlpha=1;
    } else b.trail = [];
    // draw image if exists
    if(assets[b.key]){
      const size = (b.r*2 + 8) * zoom;
      ctx.drawImage(assets[b.key], screen.x - size/2, screen.y - size/2, size, size);
    } else drawBodyShape(screen.x, screen.y, {...b, r: b.r*zoom});
    // label
    ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.font = `${11*zoom}px Inter, sans-serif`;
    ctx.fillText(b.name, screen.x + (8*zoom), screen.y + (4*zoom));
    b._screen = screen; b._world = {x:wx,y:wy};
  });

  // comet
  const cpos = worldToScreen(comet._pos.x, comet._pos.y);
  comet.trail.push({x:cpos.x,y:cpos.y});
  if(comet.trail.length>80) comet.trail.shift();
  ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.22)'; comet.trail.forEach((p,i)=> i? ctx.lineTo(p.x,p.y): ctx.moveTo(p.x,p.y)); ctx.stroke();
  if(assets['comet']){
    const s = (comet.r*2+6)*zoom;
    ctx.drawImage(assets['comet'], cpos.x - s/2, cpos.y - s/2, s, s);
  } else { ctx.beginPath(); ctx.fillStyle=comet.color; ctx.arc(cpos.x,cpos.y,comet.r*zoom,0,Math.PI*2); ctx.fill();}

  // ship
  const shipScreen = worldToScreen(ship.x, ship.y);
  ctx.save();
  ctx.translate(shipScreen.x, shipScreen.y);
  ctx.rotate(ship.angle);
  if(assets['ship']){
    const s = 28*zoom;
    ctx.drawImage(assets['ship'], -s/2, -s/2, s, s);
  } else {
    ctx.beginPath(); ctx.fillStyle='#e8f2ff'; ctx.moveTo(12*zoom,0); ctx.lineTo(-8*zoom,8*zoom); ctx.lineTo(-6*zoom,0); ctx.lineTo(-8*zoom,-8*zoom); ctx.fill();
  }
  ctx.restore();

  timeLabel.textContent = `Tiempo ${Math.floor(time)}`;
  document.getElementById('status').textContent = `Cuerpos: ${bodies.length+1} · Zoom: ${zoom.toFixed(2)}x · Sim: ${simSpeed}x`;
  document.getElementById('speedVal').textContent = simSpeed;
}

/* =========================
   Interacciones UI
   ========================= */
document.getElementById('pauseBtn').addEventListener('click', e=>{ running=!running; e.target.textContent = running? 'Pausar':'Continuar';});
document.getElementById('fasterBtn').addEventListener('click', ()=>{ simSpeed*=2; if(simSpeed>4) simSpeed=1; document.getElementById('speedVal').textContent = simSpeed;});
document.getElementById('toggleOrbits').addEventListener('click', ()=>{ showOrbits=!showOrbits;});
document.getElementById('toggleTrails').addEventListener('click', ()=>{ showTrails=!showTrails;});
document.getElementById('resetBtn').addEventListener('click', ()=>{ time=0; simSpeed=1; zoom=1; viewOffset={x:0,y:0}; zoomHistory=[]; redoHistory=[]; addLog('Sistema reiniciado');});
document.getElementById('eventBtn').addEventListener('click', ()=> triggerRandomEvent());

document.getElementById('speed').addEventListener('input', e=>{ simSpeed = parseFloat(e.target.value); document.getElementById('speedVal').textContent = simSpeed;});
document.getElementById('ambRange').addEventListener('input', e=>{ const v=parseFloat(e.target.value); document.getElementById('ambLevel').textContent=v; if(audioCtx) gain.gain.value = 0.01*v;});

/* zoom controls con undo/redo */
function pushZoomState(){
  zoomHistory.push({zoom, viewOffset: {...viewOffset}});
  if(zoomHistory.length>30) zoomHistory.shift();
  redoHistory = [];
}
function setZoom(z, vo){
  pushZoomState();
  zoom = Math.max(0.2, Math.min(3, z));
  if(vo) viewOffset = {...vo};
}
document.getElementById('zoomIn').addEventListener('click', ()=> setZoom(zoom*1.2));
document.getElementById('zoomOut').addEventListener('click', ()=> setZoom(zoom/1.2));
document.getElementById('undoZoom').addEventListener('click', ()=>{
  if(zoomHistory.length){
    redoHistory.push({zoom, viewOffset:{...viewOffset}});
    const s = zoomHistory.pop();
    zoom = s.zoom; viewOffset = {...s.viewOffset};
  }
});
document.getElementById('redoZoom').addEventListener('click', ()=>{
  if(redoHistory.length){
    const s = redoHistory.pop();
    pushZoomState();
    zoom = s.zoom; viewOffset = {...s.viewOffset};
  }
});

/* click para centrar en planeta */
canvas.addEventListener('click', e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  // check planets
  const clicked = bodies.concat([comet]).find(b=>{
    if(!b._screen) return false;
    const dx = mx - b._screen.x, dy = my - b._screen.y;
    return Math.sqrt(dx*dx+dy*dy) < (b.r*zoom + 8);
  });
  if(clicked){
    // animar pan y zoom
    const target = clicked._world || comet._pos || {x:0,y:0};
    animatePanZoom(target, 1.6);
    addLog('Centrado en ' + clicked.name);
  }
});

/* pan con ratón arrastrando la vista */
let dragging=false, lastMouse=null;
canvas.addEventListener('mousedown', e=>{ dragging=true; lastMouse={x:e.clientX,y:e.clientY}; canvas.style.cursor='grabbing'; });
window.addEventListener('mouseup', ()=>{ dragging=false; lastMouse=null; canvas.style.cursor='default'; });
window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx = (e.clientX - lastMouse.x)/zoom;
  const dy = (e.clientY - lastMouse.y)/zoom;
  viewOffset.x += dx; viewOffset.y += dy;
  lastMouse = {x:e.clientX,y:e.clientY};
});

/* animate pan and zoom */
function animatePanZoom(targetWorld, targetZoom){
  const fromZoom = zoom, fromOffset = {...viewOffset};
  const toZoom = targetZoom;
  // aim to center target
  const toOffset = { x: -targetWorld.x, y: -targetWorld.y };
  pushZoomState();
  const t0 = performance.now();
  function anim(now){
    const p = Math.min(1, (now - t0)/600);
    const ease = p<0.5? 2*p*p : -1 + (4-2*p)*p;
    zoom = fromZoom + (toZoom - fromZoom) * ease;
    viewOffset.x = fromOffset.x + (toOffset.x - fromOffset.x)*ease;
    viewOffset.y = fromOffset.y + (toOffset.y - fromOffset.y)*ease;
    if(p<1) requestAnimationFrame(anim);
  }
  requestAnimationFrame(anim);
}

/* =========================
   Nave controlable (WASD)
   ========================= */
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; ship.thrust=false; ship.boost=false; });

function shipControlTick(dt){
  // rotation with A/D or left/right
  if(keys['a']) ship.angle -= 3 * dt;
  if(keys['d']) ship.angle += 3 * dt;
  // thrust with w
  ship.thrust = !!keys['w'];
  ship.boost = !!keys[' '];
  // reverse with s
  if(keys['s']){ ship.vx *= 0.98; ship.vy *= 0.98; }
}
setInterval(()=> shipControlTick(0.016), 16);

/* =========================
   Random events y efectos
   ========================= */
function triggerRandomEvent(){
  const ev = randChoice(['Solar Flare','Eclipse','Gravity Anomaly','Meteor Shower','Comet Flyby']);
  if(ev === 'Solar Flare'){ flashScreen('#ffb86b'); addLog('Solar Flare: registros alterados'); }
  else if(ev === 'Eclipse'){ dimScreen(); addLog('Eclipse: luz reducida'); }
  else if(ev === 'Gravity Anomaly'){ distortOrbits(); addLog('Anomalía gravitacional'); }
  else if(ev === 'Meteor Shower'){ spawnMeteors(); addLog('Lluvia de meteoros'); }
  else { // Comet Flyby creates close approach
    addLog('Comet Flyby: acercamiento del cometa');
    animatePanZoom(comet._pos, 2.2);
  }
}


function flashScreen(col){ const overlay=document.createElement('div'); overlay.style.position='absolute'; overlay.style.left=0; overlay.style.top=0; overlay.style.width='100%'; overlay.style.height='100%'; overlay.style.background=col; overlay.style.opacity=0.25; overlay.style.pointerEvents='none'; simEl.appendChild(overlay); setTimeout(()=>overlay.remove(),800); }
function dimScreen(){ simEl.style.transition='filter 1.2s'; simEl.style.filter='brightness(0.5)'; setTimeout(()=>{ simEl.style.filter=''; },3000); }
function distortOrbits(){ bodies.forEach(b=> b.d += (Math.random()-0.5)*40); setTimeout(()=>{ bodies.forEach((b,i)=> b.d=[80,140,220,320,420][i]); addLog('Órbitas recuperadas') },7000); }
function spawnMeteors(){ for(let i=0;i<18;i++){ setTimeout(()=>{ const x0=Math.random()*W, y0=0, x1=Math.random()*W, y1=H; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke(); setTimeout(()=>{},80); }, i*60); } }

/* =========================
   Logs y notas
   ========================= */
function addLog(txt){
  const div = document.createElement('div');
  div.className = 'entry unread';
  div.innerHTML = `<div><strong>${txt}</strong><div class="small">Registro automático</div></div><div><button data-action="mark">Leer</button></div>`;
  logEl.prepend(div);
}
document.getElementById('addNote').addEventListener('click', ()=>{ const v=document.getElementById('noteInput').value.trim(); if(!v) return; addLog(v); document.getElementById('noteInput').value=''; });
logEl.addEventListener('click', e=>{ if(e.target.tagName==='BUTTON'){ const entry=e.target.closest('.entry'); entry.classList.remove('unread'); e.target.textContent='Leído'; e.target.disabled=true; }});

/* =========================
   Drag & drop assets y input file
   ========================= */
const fileInput = document.getElementById('fileInput');
fileInput.addEventListener('change', async e=>{ const files = Array.from(e.target.files); await handleFiles(files); e.target.value=''; });

async function handleFiles(files){
  for(const f of files){
    const name = f.name.split('.').slice(0,-1).join('').toLowerCase();
    const reader = new FileReader();
    await new Promise(res=>{ reader.onload = ()=>{ const img = new Image(); img.onload = ()=>{ assets[name]=img; addLog(`Asset cargado: ${name}`); res(); }; img.src = reader.result; }; reader.readAsDataURL(f); });
  }
}
['dragover','dragenter'].forEach(ev=>{ document.addEventListener(ev, e=>{ e.preventDefault(); }); });
document.addEventListener('drop', async e=>{ e.preventDefault(); const files = Array.from(e.dataTransfer.files); if(files.length) await handleFiles(files); });

/* =========================
   Carga de imágenes por URL si el usuario prefiere pegar rutas
   ========================= */
/* =========================
   Debug inicial
   ========================= */
setTimeout(()=>{ addLog('Primera exploración: sistema estable'); logEvent('Sistema listo'); },600);

/* =========================
   Verbose: controles de teclado para zoom y centrar en home
   ========================= */
window.addEventListener('keydown', e=>{
  if(e.key === '=') setZoom(zoom*1.15);
  if(e.key === '-') setZoom(zoom/1.15);
  if(e.key === '0'){ animatePanZoom({x:0,y:0},1); addLog('Centrado en Sol'); }
});

</script>
<style>
/* Overlay minimalista y seguro */
.ow-simple-wrap { position: relative; display: inline-block; }
.ow-stars-canvas {
  position: absolute; left: 0; top: 0; pointer-events: none; z-index: 5;
}
.ow-controls-mini {
  position: fixed; right: 12px; bottom: 12px; z-index: 60;
  background: rgba(2,6,12,0.75); color:#e6f3ff; padding:8px 10px; border-radius:8px;
  font-family: Inter, system-ui, sans-serif; font-size:13px; box-shadow:0 8px 24px rgba(0,0,0,0.5);
}
.ow-hint { opacity:0.9; color:#d0e8ff; }
</style>

<script>
(function(){
  // Selecciona la imagen objetivo: primera imagen visible con 'map' o la primera img
  const imgs = Array.from(document.querySelectorAll('img')).filter(i=> i.clientWidth>40 && i.clientHeight>40);
  const targetImg = imgs.find(i=> /map|mapa|system|outer/i.test((i.src + ' ' + (i.alt||'')))) || imgs[0];
  if(!targetImg) return;

  // Asegurar que el padre es relativo sin modificar la imagen en sí
  const parent = targetImg.parentElement;
  parent.style.position = parent.style.position || 'relative';
  parent.classList.add('ow-simple-wrap');

  // Crear canvas para estrellas encima de la imagen
  const stars = document.createElement('canvas');
  stars.className = 'ow-stars-canvas';
  parent.appendChild(stars);

  // Crear capa de transformación (wrapper) que no modifica el <img> original; aplicamos transform aquí
  // Usamos un envoltorio visual (parent) para aplicar transform; la imagen queda dentro del mismo contenedor
  let zoom = 1;
  let offset = {x:0,y:0};
  const history = [], redo = [];

  function pushHistory(){
    history.push({zoom, offset:{x:offset.x, y:offset.y}});
    if(history.length>60) history.shift();
    redo.length = 0;
  }

  function applyTransform(z, off){
    zoom = Math.max(0.4, Math.min(3, z));
    if(off) offset = {x: off.x, y: off.y};
    parent.style.transformOrigin = '50% 50%';
    parent.style.transform = `translate(${offset.x}px, ${offset.y}px) scale(${zoom})`;
  }

  // Resize and paint stars
  function resizeAndPaint(){
    const rect = targetImg.getBoundingClientRect();
    const w = Math.max(2, Math.round(rect.width));
    const h = Math.max(2, Math.round(rect.height));
    stars.width = w; stars.height = h;
    stars.style.width = rect.width + 'px';
    stars.style.height = rect.height + 'px';
    stars.style.left = (targetImg.offsetLeft) + 'px';
    stars.style.top  = (targetImg.offsetTop) + 'px';
    paintStars(stars.getContext('2d'), w, h);
  }

  // Muestra pequeñas estrellas blancas dispersas
  function paintStars(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    // opcional: fondo del contenedor ya ajustado; aquí sólo pintamos estrellas
    const count = Math.max(40, Math.round((w*h)/12000));
    for(let i=0;i<count;i++){
      const x = Math.random()*w;
      const y = Math.random()*h;
      const s = Math.random()*1.6;
      const a = 0.5 + Math.random()*0.9;
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.arc(x,y,s,0,Math.PI*2);
      ctx.fill();
    }
  }

  // Samplea color de la esquina superior izquierda de la imagen para usarlo como fondo del contenedor
  function sampleCornerColor(img){
    try{
      const c = document.createElement('canvas');
      c.width = c.height = 4;
      const cx = c.getContext('2d');
      cx.drawImage(img, 0, 0, 4, 4);
      const d = cx.getImageData(0,0,4,4).data;
      // promedio de la esquina 2x2
      let r=0,g=0,b=0,cnt=0;
      for(let y=0;y<2;y++) for(let x=0;x<2;x++){
        const i = (y*4 + x)*4;
        r += d[i]; g += d[i+1]; b += d[i+2]; cnt++;
      }
      r = Math.round(r/cnt); g = Math.round(g/cnt); b = Math.round(b/cnt);
      return `rgb(${r},${g},${b})`;
    }catch(e){
      return null;
    }
  }

  // Aplicar color de fondo del contenedor igual al muestreado
  function applyBgFromImage(){
    const col = sampleCornerColor(targetImg);
    if(col) parent.style.background = col;
  }

  // Wheel zoom handling with undo/redo
  let wheelTimeout = null;
  function onWheel(e){
    if(e.ctrlKey) return; // let browser default when Ctrl used
    e.preventDefault();
    const delta = -e.deltaY;
    const factor = (delta>0) ? 1.08 : 0.92;
    const rect = targetImg.getBoundingClientRect();
    // zoom toward mouse position in image coordinates
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const worldX = (mx - rect.width/2 - offset.x)/zoom;
    const worldY = (my - rect.height/2 - offset.y)/zoom;
    const newZoom = Math.max(0.4, Math.min(3, zoom * factor));
    const newOffsetX = -(worldX * newZoom) + (rect.width/2);
    const newOffsetY = -(worldY * newZoom) + (rect.height/2);
    // convert offset to parent transform coordinates (center-based)
    const off = {x: newOffsetX - rect.width/2, y: newOffsetY - rect.height/2};
    // push only when continuous wheel ends (debounced) to prevent huge history
    if(!wheelTimeout){ pushHistory(); }
    applyTransform(newZoom, off);
    clearTimeout(wheelTimeout);
    wheelTimeout = setTimeout(()=>{ wheelTimeout = null; }, 250);
  }

  // Undo/redo functions
  function undo(){
    if(history.length){
      redo.push({zoom, offset:{x:offset.x, y:offset.y}});
      const s = history.pop();
      applyTransform(s.zoom, s.offset);
    }
  }
  function redoCmd(){
    if(redo.length){
      const s = redo.pop();
      pushHistory();
      applyTransform(s.zoom, s.offset);
    }
  }

  // Events
  targetImg.addEventListener('load', ()=>{ applyBgFromImage(); resizeAndPaint(); });
  // init
  applyBgFromImage();
  resizeAndPaint();
  window.addEventListener('resize', resizeAndPaint);

  // wheel on parent area (so image itself is unchanged)
  parent.addEventListener('wheel', onWheel, {passive:false});

  // keyboard undo/redo (Ctrl+Z / Ctrl+Y or z/y without ctrl)
  window.addEventListener('keydown', (ev)=>{
    if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase()==='z'){ ev.preventDefault(); undo(); }
    if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase()==='y'){ ev.preventDefault(); redoCmd(); }
    if(!ev.ctrlKey && ev.key.toLowerCase()==='z'){ undo(); }
    if(!ev.ctrlKey && ev.key.toLowerCase()==='y'){ redoCmd(); }
  });

  // Minimal UI hint
  const ctrl = document.createElement('div');
  ctrl.className = 'ow-controls-mini';
  ctrl.innerHTML = '<div class="ow-hint">Rueda: zoom · Ctrl+Z / Ctrl+Y: deshacer/rehacer</div>';
  document.body.appendChild(ctrl);

  // inicial push
  pushHistory();

})();
</script>
<!-- ZOOM WHEEL + UNDO/REDO: pega antes de </body> -->
<style>
  /* estilos mínimos para los botones (opcionales) */
  .zoom-controls {
    position: fixed; right: 12px; bottom: 12px; z-index:10000;
    background: rgba(0,0,0,0.6); color:#fff; padding:8px; border-radius:8px; font-family:system-ui;
  }
  .zoom-controls button { margin:0 6px 6px 0; padding:6px 8px; border-radius:6px; border:0; background:#194; color:#fff; cursor:pointer; }
</style>

<script>
(function(){
  // Selecciona el contenedor objetivo: preferimos .map-wrap, sino el primer elemento con <img>
  let target = document.querySelector('.map-wrap');
  if(!target){
    const img = document.querySelector('img');
    if(!img) return;
    target = img.parentElement || document.body;
  }

  // Estado transform
  let zoom = 1;
  let offset = { x: 0, y: 0 }; // translation in px
  const MIN_Z = 0.4, MAX_Z = 3.0;

  // Historial undo/redo
  const history = [];
  const redoStack = [];
  function pushHistory(){
    history.push({ zoom, offset: { x: offset.x, y: offset.y } });
    if(history.length > 80) history.shift();
    redoStack.length = 0;
  }
  function undo(){
    if(history.length === 0) return;
    redoStack.push({ zoom, offset: { x: offset.x, y: offset.y } });
    const s = history.pop();
    zoom = s.zoom; offset = { x: s.offset.x, y: s.offset.y };
    applyTransform();
  }
  function redo(){
    if(redoStack.length === 0) return;
    const s = redoStack.pop();
    pushHistory();
    zoom = s.zoom; offset = { x: s.offset.x, y: s.offset.y };
    applyTransform();
  }

  // Aplicar transform al contenedor sin tocar la imagen fuente
  function applyTransform(){
    target.style.transformOrigin = '50% 50%';
    target.style.transform = `translate(${offset.x}px, ${offset.y}px) scale(${zoom})`;
  }

  // Wheel handler: zoom centered on mouse position
  let wheelDebounce = null;
  target.addEventListener('wheel', function(e){
    // Allow native ctrl-zoom
    if(e.ctrlKey || e.metaKey) return;
    e.preventDefault();

    // On new gesture, record history once
    if(!wheelDebounce){ pushHistory(); }
    clearTimeout(wheelDebounce);
    wheelDebounce = setTimeout(()=> wheelDebounce = null, 220);

    const rect = target.getBoundingClientRect();
    // mouse coords relative to target
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // choose factor
    const delta = -e.deltaY;
    const factor = delta > 0 ? 1.085 : 0.92;
    const newZoom = Math.max(MIN_Z, Math.min(MAX_Z, zoom * factor));

    // world coords of cursor before zoom
    const worldX = (mx - rect.width/2 - offset.x) / zoom;
    const worldY = (my - rect.height/2 - offset.y) / zoom;

    // compute new offsets so the cursor stays on same world point
    const newOffsetX = -(worldX * newZoom) + (rect.width/2);
    const newOffsetY = -(worldY * newZoom) + (rect.height/2);

    zoom = newZoom;
    offset.x = newOffsetX - rect.width/2;
    offset.y = newOffsetY - rect.height/2;

    applyTransform();
  }, { passive: false });

  // Pointer drag panning
  let dragging = false, last = null;
  target.addEventListener('pointerdown', function(e){
    if(e.button !== 0) return;
    dragging = true;
    last = { x: e.clientX, y: e.clientY };
    target.setPointerCapture && target.setPointerCapture(e.pointerId);
  });
  window.addEventListener('pointermove', function(e){
    if(!dragging) return;
    const dx = e.clientX - last.x;
    const dy = e.clientY - last.y;
    last = { x: e.clientX, y: e.clientY };
    offset.x += dx;
    offset.y += dy;
    applyTransform();
  });
  window.addEventListener('pointerup', function(e){
    if(!dragging) return;
    dragging = false;
    last = null;
    pushHistory();
  });

  // Keyboard undo/redo: Ctrl+Z / Ctrl+Y and Z / Y
  window.addEventListener('keydown', function(e){
    const key = e.key.toLowerCase();
    if((e.ctrlKey || e.metaKey) && key === 'z'){ e.preventDefault(); undo(); }
    if((e.ctrlKey || e.metaKey) && key === 'y'){ e.preventDefault(); redo(); }
    if(!e.ctrlKey && key === 'z'){ undo(); }
    if(!e.ctrlKey && key === 'y'){ redo(); }
  });

  // Optional small UI: buttons for undo/redo/zoom (uncomment if you want UI)
  const ui = document.createElement('div');
  ui.className = 'zoom-controls';
  ui.innerHTML = '<button id="zplus">+</button><button id="zminus">−</button><button id="zundo">Deshacer</button><button id="zredo">Rehacer</button>';
  document.body.appendChild(ui);
  ui.querySelector('#zplus').addEventListener('click', ()=>{ pushHistory(); zoom = Math.min(MAX_Z, zoom * 1.15); applyTransform(); });
  ui.querySelector('#zminus').addEventListener('click', ()=>{ pushHistory(); zoom = Math.max(MIN_Z, zoom / 1.15); applyTransform(); });
  ui.querySelector('#zundo').addEventListener('click', undo);
  ui.querySelector('#zredo').addEventListener('click', redo);

  // initialise history
  pushHistory();
  applyTransform();

})();
</script>

</body>
</html>
